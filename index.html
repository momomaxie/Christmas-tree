<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Luxury Particle Tree - Standalone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body, html { margin: 0; padding: 0; background-color: #000; overflow: hidden; }
      #root { width: 100vw; height: 100vh; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@^19.2.3",
        "react-dom": "https://esm.sh/react-dom@^19.2.3",
        "react-dom/client": "https://esm.sh/react-dom@^19.2.3/client",
        "three": "https://esm.sh/three@^0.182.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@^9.4.2",
        "@react-three/drei": "https://esm.sh/@react-three/drei@^10.7.7",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@^3.0.4",
        "zustand": "https://esm.sh/zustand@^5.0.9",
        "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@^0.10.22-rc.20250304"
      }
    }
    </script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useEffect, useRef, useMemo, useState, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';
      import { OrbitControls, PerspectiveCamera, Environment, Billboard } from '@react-three/drei';
      import { EffectComposer, Vignette, Bloom } from '@react-three/postprocessing';
      import * as THREE from 'three';
      import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
      import { create } from 'zustand';

      // --- Types (Inlined from types.ts) ---
      const HandGesture = {
        UNKNOWN: 'UNKNOWN',
        OPEN_PALM: 'OPEN_PALM',
        FIST: 'FIST',
        POINTING: 'POINTING',
        REST: 'REST'
      };

      // --- Global Store ---
      const useStore = create((set) => ({
        gesture: HandGesture.UNKNOWN,
        x: 0,
        y: 0,
        z: 0.5,
        pointer: null,
        isPresent: false,
        setHandState: (newState) => set((state) => ({ ...state, ...newState })),
      }));

      // --- Constants & Config ---
      const TREE_HEIGHT = 14; 
      const TREE_RADIUS = 5.0; 
      const PARTICLE_COUNT = 18000; 
      const ORNAMENT_COUNT = 400;
      const BOX_COUNT = 50;
      const LIGHT_COUNT = 800;
      const FAIRY_LIGHT_COUNT = 800; 
      const SNOW_COUNT = 2000; 
      const DUST_COUNT = 2000; 

      const COLOR_GOLD = new THREE.Color('#FFD700');
      const COLOR_RICH_GOLD = new THREE.Color('#DAA520');
      const COLOR_DEEP_RED = new THREE.Color('#8B0000');
      const COLOR_BRIGHT_RED = new THREE.Color('#D01010');
      const COLOR_EMERALD = new THREE.Color('#003315');

      const LUXURY_PALETTE = [
        new THREE.Color('#FFD700'), new THREE.Color('#C5A000'),
        new THREE.Color('#8B0000'), new THREE.Color('#D00000'),
        new THREE.Color('#DAA520'), new THREE.Color('#C0C0C0'),
        new THREE.Color('#F0F0F0'),
      ];

      const FAIRY_PALETTE = [
        new THREE.Color('#FF0000'), new THREE.Color('#DAA520'),
        new THREE.Color('#006400'), new THREE.Color('#FFD700'),
        new THREE.Color('#0000FF'),
      ];

      // --- Helper Math ---
      const randomSpherePoint = (scale) => {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = Math.cbrt(Math.random()) * scale;
        return new THREE.Vector3(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        );
      };

      // --- Shaders ---
      const foliageVertexShader = `
        uniform float uTime;
        uniform float uExplode;
        attribute vec3 aTargetPos;
        attribute vec3 aChaosPos;
        attribute float aSize;
        attribute float aSpeed;
        varying vec3 vColor;
        varying float vAlpha;
        float easeOutCubic(float x) { return 1.0 - pow(1.0 - x, 3.0); }
        void main() {
          float progress = easeOutCubic(1.0 - uExplode); 
          vec3 noise = vec3(
            sin(uTime * aSpeed + aTargetPos.y),
            cos(uTime * aSpeed * 0.5 + aTargetPos.x),
            sin(uTime * aSpeed * 0.8 + aTargetPos.z)
          ) * 0.1;
          vec3 newPos = mix(aChaosPos, aTargetPos, progress) + noise;
          vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = aSize * (350.0 / -mvPosition.z); 
          vec3 emerald = vec3(0.0, 0.35, 0.15); 
          vec3 richGold = vec3(1.0, 0.84, 0.0);
          vec3 deepGold = vec3(0.85, 0.65, 0.13);
          float seed = fract(sin(dot(aChaosPos.xy, vec2(12.9898, 78.233))) * 43758.5453);
          if (seed > 0.85) {
              vColor = mix(richGold, deepGold, sin(uTime + aTargetPos.y));
              vAlpha = 1.0;
          } else {
              float heightFactor = (newPos.y + 6.0) / 12.0;
              vColor = mix(vec3(0.0, 0.15, 0.05), emerald, heightFactor);
              vAlpha = 0.9;
          }
        }
      `;

      const foliageFragmentShader = `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
          if (dot(circCoord, circCoord) > 1.0) discard;
          float alpha = 1.0 - smoothstep(0.8, 1.0, length(circCoord));
          gl_FragColor = vec4(vColor, alpha * vAlpha);
        }
      `;

      const lightVertexShader = `
        uniform float uTime;
        uniform float uExplode;
        attribute vec3 aTargetPos;
        attribute vec3 aChaosPos;
        attribute float aPhase;
        attribute float aSpeed;
        varying float vAlpha;
        float easeOutCubic(float x) { return 1.0 - pow(1.0 - x, 3.0); }
        void main() {
          float progress = easeOutCubic(1.0 - uExplode);
          vec3 newPos = mix(aChaosPos, aTargetPos, progress);
          vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = 25.0 * (10.0 / -mvPosition.z); 
          float blink = sin(uTime * 3.0 * aSpeed + aPhase);
          vAlpha = smoothstep(0.1, 1.0, blink); 
        }
      `;

      const lightFragmentShader = `
        varying float vAlpha;
        void main() {
          vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
          float dist = length(circCoord);
          if (dist > 1.0) discard;
          float strength = 1.0 - dist;
          strength = pow(strength, 3.0);
          vec3 color = vec3(1.0, 0.9, 0.7); 
          gl_FragColor = vec4(color, strength * vAlpha * 4.0); 
        }
      `;

      const fairyLightVertexShader = `
        uniform float uTime;
        uniform float uExplode;
        attribute vec3 aTargetPos;
        attribute vec3 aChaosPos;
        attribute float aPhase;
        attribute float aSpeed;
        attribute vec3 aColor;
        varying float vAlpha;
        varying vec3 vColor;
        float easeOutCubic(float x) { return 1.0 - pow(1.0 - x, 3.0); }
        void main() {
          float progress = easeOutCubic(1.0 - uExplode);
          vec3 newPos = mix(aChaosPos, aTargetPos, progress);
          vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = 18.0 * (10.0 / -mvPosition.z); 
          vColor = aColor;
          float blink = sin(uTime * 4.0 * aSpeed + aPhase);
          vAlpha = smoothstep(0.0, 1.0, blink); 
        }
      `;

      const fairyLightFragmentShader = `
        varying float vAlpha;
        varying vec3 vColor;
        void main() {
          vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
          float dist = length(circCoord);
          if (dist > 1.0) discard;
          float strength = 1.0 - dist;
          strength = pow(strength, 2.0);
          gl_FragColor = vec4(vColor, strength * vAlpha);
        }
      `;

      const snowVertexShader = `
        uniform float uTime;
        uniform float uHeight;
        attribute float aSpeed;
        attribute float aDrift;
        void main() {
          vec3 pos = position;
          float fallOffset = uTime * aSpeed;
          pos.y = mod(position.y - fallOffset + uHeight/2.0, uHeight) - uHeight/2.0;
          pos.x += sin(uTime * aDrift + position.y) * 0.5;
          pos.z += cos(uTime * aDrift + position.x) * 0.5;
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = 120.0 * (1.0 / -mvPosition.z); 
        }
      `;

      const snowFragmentShader = `
        void main() {
          vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
          float dist = length(circCoord);
          if (dist > 1.0) discard;
          float alpha = 1.0 - smoothstep(0.0, 1.0, dist);
          gl_FragColor = vec4(0.9, 0.95, 1.0, alpha * 0.4); 
        }
      `;

      const dustVertexShader = `
        uniform float uTime;
        attribute float aPhase;
        attribute float aSpeed;
        varying float vAlpha;
        void main() {
          vec3 pos = position;
          float yOffset = sin(uTime * aSpeed * 0.5 + aPhase) * 1.0;
          pos.y += yOffset;
          float angle = uTime * 0.1 * aSpeed;
          float c = cos(angle); float s = sin(angle);
          float x = pos.x * c - pos.z * s; float z = pos.x * s + pos.z * c;
          pos.x = x; pos.z = z;
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = 45.0 * (1.0 / -mvPosition.z); 
          vAlpha = 0.6 + 0.4 * sin(uTime * 3.0 + aPhase);
        }
      `;

      const dustFragmentShader = `
        varying float vAlpha;
        void main() {
          vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
          if (abs(circCoord.x) > 0.8 || abs(circCoord.y) > 0.8) discard;
          vec3 color = vec3(1.0, 0.84, 0.0); 
          gl_FragColor = vec4(color, vAlpha);
        }
      `;

      const starGlowVertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      const starGlowFragmentShader = `
        varying vec2 vUv;
        uniform float uTime;
        void main() {
          float dist = distance(vUv, vec2(0.5));
          float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
          alpha = pow(alpha, 1.5); 
          float pulse = sin(uTime * 4.0) * 0.2 + 0.8;
          vec3 color = vec3(1.0, 0.9, 0.7) * pulse; 
          gl_FragColor = vec4(color, alpha * 0.8);
        }
      `;

      const ribbonVertexShader = `
        uniform float uTime;
        attribute float aProgress;
        attribute vec3 aOffset;
        varying float vAlpha;
        varying vec3 vColor;
        void main() {
          float t = fract(aProgress + uTime * 0.05);
          float h = 14.0;
          float y = (t - 0.5) * h;
          float r = 6.0 * (1.0 - t * 0.8); 
          float turns = 5.0;
          float angle = -t * 6.28318 * turns;
          vec3 pos = vec3(r * cos(angle), y, r * sin(angle)) + aOffset;
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = 40.0 * (1.0 / -mvPosition.z);
          float fade = smoothstep(0.0, 0.1, t) * (1.0 - smoothstep(0.95, 1.0, t));
          vAlpha = fade;
          vColor = mix(vec3(1.0, 0.84, 0.0), vec3(1.0, 1.0, 0.9), sin(t * 20.0 + uTime) * 0.5 + 0.5);
        }
      `;

      const ribbonFragmentShader = `
        varying float vAlpha;
        varying vec3 vColor;
        void main() {
          vec2 pc = 2.0 * gl_PointCoord - 1.0;
          float d = length(pc);
          if (d > 1.0) discard;
          float glow = pow(1.0 - d, 2.0);
          gl_FragColor = vec4(vColor, glow * vAlpha * 0.8);
        }
      `;

      // --- Components ---

      const HandTracker = () => {
        const videoRef = useRef(null);
        const { setHandState } = useStore();
        const [loaded, setLoaded] = useState(false);

        useEffect(() => {
          let handLandmarker = null;
          let animationFrameId;

          const setupMediaPipe = async () => {
            try {
              const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
              );
              handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                  modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                  delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
              });
              setLoaded(true);
              startWebcam();
            } catch (e) { console.error(e); }
          };

          const startWebcam = async () => {
            if (navigator.mediaDevices?.getUserMedia) {
              const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
              if (videoRef.current) {
                videoRef.current.srcObject = stream;
                videoRef.current.addEventListener('loadeddata', predictWebcam);
              }
            }
          };

          const predictWebcam = async () => {
            if (!handLandmarker || !videoRef.current) return;
            const result = handLandmarker.detectForVideo(videoRef.current, performance.now());
            if (result.landmarks?.length > 0) {
              const landmarks = result.landmarks[0];
              const palmX = (landmarks[0].x + landmarks[9].x) / 2;
              const palmY = (landmarks[0].y + landmarks[9].y) / 2;
              const normX = (palmX - 0.5) * 2 * -1;
              const normY = (palmY - 0.5) * 2;
              
              let gesture = HandGesture.UNKNOWN;
              const isExtended = (tip, pip) => Math.sqrt(Math.pow(tip.x - landmarks[0].x, 2) + Math.pow(tip.y - landmarks[0].y, 2)) > Math.sqrt(Math.pow(pip.x - landmarks[0].x, 2) + Math.pow(pip.y - landmarks[0].y, 2));
              const openCount = [isExtended(landmarks[4], landmarks[2]), isExtended(landmarks[8], landmarks[6]), isExtended(landmarks[12], landmarks[10]), isExtended(landmarks[16], landmarks[14]), isExtended(landmarks[20], landmarks[18])].filter(Boolean).length;
              
              if (openCount >= 4) gesture = HandGesture.OPEN_PALM;
              else if (openCount <= 1) gesture = isExtended(landmarks[8], landmarks[6]) ? HandGesture.POINTING : HandGesture.FIST;

              setHandState({
                isPresent: true, x: normX, y: normY, z: Math.abs(landmarks[0].z * 100), gesture,
                pointer: { x: (landmarks[8].x - 0.5) * 20 * -1, y: (landmarks[8].y - 0.5) * 20 * -1, z: landmarks[8].z * 10 }
              });
            } else setHandState({ isPresent: false, gesture: HandGesture.UNKNOWN });
            animationFrameId = requestAnimationFrame(predictWebcam);
          };

          setupMediaPipe();
          return () => { cancelAnimationFrame(animationFrameId); handLandmarker?.close(); };
        }, []);

        return (
          <div className="absolute top-6 left-6 z-50 flex flex-col items-start gap-4 pointer-events-none md:pointer-events-auto">
            <div className="relative p-1 bg-gradient-to-br from-[#FFD700] via-[#F0E68C] to-[#B8860B] rounded-sm shadow-lg">
              <div className="relative w-52 h-40 bg-black border-2 border-black overflow-hidden">
                <video ref={videoRef} className="w-full h-full object-cover transform -scale-x-100 opacity-80" autoPlay playsInline muted />
                <div className="absolute top-0 left-0 w-full bg-black/80 text-[#FFD700] text-center text-[10px] tracking-[0.2em] py-1 border-b border-[#B8860B]">SYSTEM ACTIVE</div>
                {!loaded && <div className="absolute inset-0 flex items-center justify-center text-[#FFD700] text-xs animate-pulse tracking-widest">INITIALIZING...</div>}
                <div className="absolute bottom-0 w-full bg-black/90 p-2 text-center border-t border-[#B8860B]">
                  <span className="text-[#FFD700] text-xs font-serif uppercase tracking-wider">{useStore(s => s.isPresent ? s.gesture : "AWAITING INPUT")}</span>
                </div>
              </div>
            </div>
            <div className="w-full border-2 border-[#B8860B] bg-black/90 p-4 shadow-lg text-[#FFD700]">
              <h2 className="text-sm font-serif font-bold border-b border-[#B8860B] pb-2 mb-2 tracking-widest text-center uppercase">Control Panel</h2>
              <div className="space-y-1 text-xs font-serif tracking-wide text-[#F0E68C]">
                <p className="flex justify-between"><span>OPEN PALM</span> <span>:: EXPLODE</span></p>
                <p className="flex justify-between"><span>FIST</span> <span>:: GATHER</span></p>
                <p className="flex justify-between"><span>POINT</span> <span>:: LIGHT</span></p>
                <p className="flex justify-between"><span>MOVE</span> <span>:: ROTATE</span></p>
              </div>
            </div>
          </div>
        );
      };

      const TreeBase = () => (
        <group position={[0, -TREE_HEIGHT/2 - 0.5, 0]}>
          <mesh><cylinderGeometry args={[1.2, 1.8, 1.5, 32]} /><meshStandardMaterial color={COLOR_DEEP_RED} roughness={0.4} /></mesh>
          <mesh position={[0, 0.7, 0]}><torusGeometry args={[1.25, 0.08, 16, 64]} /><meshStandardMaterial color={COLOR_GOLD} metalness={1.0} /></mesh>
          <mesh position={[0, -0.7, 0]}><torusGeometry args={[1.85, 0.08, 16, 64]} /><meshStandardMaterial color={COLOR_GOLD} metalness={1.0} /></mesh>
        </group>
      );

      const Snowflakes = () => {
        const shaderRef = useRef();
        const { attr } = useMemo(() => {
          const pos = [], spd = [], drf = [];
          for (let i = 0; i < SNOW_COUNT; i++) {
            pos.push((Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60);
            spd.push(Math.random() * 2 + 1); drf.push(Math.random() * Math.PI * 2);
          }
          return { attr: { pos: new Float32Array(pos), spd: new Float32Array(spd), drf: new Float32Array(drf) } };
        }, []);
        useFrame(({ clock }) => { if (shaderRef.current) shaderRef.current.uniforms.uTime.value = clock.getElapsedTime(); });
        return (
          <points>
            <bufferGeometry>
              <bufferAttribute attach="attributes-position" count={SNOW_COUNT} array={attr.pos} itemSize={3} />
              <bufferAttribute attach="attributes-aSpeed" count={SNOW_COUNT} array={attr.spd} itemSize={1} />
              <bufferAttribute attach="attributes-aDrift" count={SNOW_COUNT} array={attr.drf} itemSize={1} />
            </bufferGeometry>
            <shaderMaterial ref={shaderRef} vertexShader={snowVertexShader} fragmentShader={snowFragmentShader} transparent depthWrite={false} blending={THREE.AdditiveBlending} uniforms={{ uTime: { value: 0 }, uHeight: { value: 60.0 } }} />
          </points>
        );
      };

      const ParticleRibbon = () => {
        const shaderRef = useRef();
        const { attr } = useMemo(() => {
          const prog = new Float32Array(3000), off = new Float32Array(3000 * 3);
          for(let i=0; i<3000; i++) {
            prog[i] = Math.random();
            off[i*3] = (Math.random()-0.5)*0.6; off[i*3+1] = (Math.random()-0.5)*0.6; off[i*3+2] = (Math.random()-0.5)*0.6;
          }
          return { attr: { prog, off } };
        }, []);
        useFrame(({ clock }) => { if (shaderRef.current) shaderRef.current.uniforms.uTime.value = clock.getElapsedTime(); });
        return (
          <points frustumCulled={false}>
            <bufferGeometry>
              <bufferAttribute attach="attributes-aProgress" count={3000} array={attr.prog} itemSize={1} />
              <bufferAttribute attach="attributes-aOffset" count={3000} array={attr.off} itemSize={3} />
              <bufferAttribute attach="attributes-position" count={3000} array={attr.off} itemSize={3} />
            </bufferGeometry>
            <shaderMaterial ref={shaderRef} vertexShader={ribbonVertexShader} fragmentShader={ribbonFragmentShader} transparent depthWrite={false} blending={THREE.AdditiveBlending} uniforms={{ uTime: { value: 0 } }} />
          </points>
        );
      };

      const Foliage = () => {
        const shaderRef = useRef();
        const handState = useStore();
        const { attr } = useMemo(() => {
          const tgt = [], chs = [], siz = [], spd = [];
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const y = (Math.random() - 0.5) * TREE_HEIGHT;
            const hp = (y + TREE_HEIGHT/2) / TREE_HEIGHT;
            const r = Math.sqrt(Math.random()) * TREE_RADIUS * (1.0 - hp);
            const th = Math.random() * Math.PI * 2;
            tgt.push(r * Math.cos(th), y, r * Math.sin(th));
            const c = randomSpherePoint(15); chs.push(c.x, c.y, c.z);
            siz.push(Math.random() * 0.4 + 0.1); spd.push(Math.random() * 0.5 + 0.5);
          }
          return { attr: { tgt: new Float32Array(tgt), chs: new Float32Array(chs), siz: new Float32Array(siz), spd: new Float32Array(spd) } };
        }, []);
        useFrame(({ clock }) => {
          if (shaderRef.current) {
            shaderRef.current.uniforms.uTime.value = clock.getElapsedTime();
            const target = handState.gesture === HandGesture.OPEN_PALM ? 1.0 : 0.0;
            shaderRef.current.uniforms.uExplode.value = THREE.MathUtils.lerp(shaderRef.current.uniforms.uExplode.value, target, 0.1);
          }
        });
        return (
          <points>
            <bufferGeometry>
              <bufferAttribute attach="attributes-aTargetPos" count={PARTICLE_COUNT} array={attr.tgt} itemSize={3} />
              <bufferAttribute attach="attributes-aChaosPos" count={PARTICLE_COUNT} array={attr.chs} itemSize={3} />
              <bufferAttribute attach="attributes-aSize" count={PARTICLE_COUNT} array={attr.siz} itemSize={1} />
              <bufferAttribute attach="attributes-aSpeed" count={PARTICLE_COUNT} array={attr.spd} itemSize={1} />
              <bufferAttribute attach="attributes-position" count={PARTICLE_COUNT} array={attr.tgt} itemSize={3} />
            </bufferGeometry>
            <shaderMaterial ref={shaderRef} vertexShader={foliageVertexShader} fragmentShader={foliageFragmentShader} transparent depthWrite={false} uniforms={{ uTime: { value: 0 }, uExplode: { value: 0 } }} />
          </points>
        );
      };

      const Ornaments = () => {
        const meshRef = useRef();
        const handState = useStore();
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const data = useMemo(() => new Array(ORNAMENT_COUNT).fill(0).map(() => {
          const y = (Math.random() - 0.5) * TREE_HEIGHT;
          const hp = (y + TREE_HEIGHT/2) / TREE_HEIGHT;
          const th = Math.random() * Math.PI * 2;
          const r = (TREE_RADIUS - 0.2) * (1.0 - hp);
          return { tgt: new THREE.Vector3(r * Math.cos(th), y, r * Math.sin(th)), chs: randomSpherePoint(20), clr: LUXURY_PALETTE[Math.floor(Math.random() * LUXURY_PALETTE.length)], scl: Math.random() * 0.2 + 0.15, spd: Math.random() * 0.05 + 0.02 };
        }), []);
        useEffect(() => {
          if (meshRef.current) {
            data.forEach((d, i) => meshRef.current.setColorAt(i, d.clr));
            meshRef.current.instanceColor.needsUpdate = true;
          }
        }, [data]);
        useFrame(() => {
          if (!meshRef.current) return;
          const exp = handState.gesture === HandGesture.OPEN_PALM;
          data.forEach((d, i) => {
            meshRef.current.getMatrixAt(i, dummy.matrix);
            dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
            dummy.position.lerp(exp ? d.chs : d.tgt, exp ? 0.05 : d.spd);
            dummy.rotation.x += 0.01; dummy.rotation.y += 0.01;
            dummy.scale.setScalar(d.scl); dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          });
          meshRef.current.instanceMatrix.needsUpdate = true;
        });
        return (
          <instancedMesh ref={meshRef} args={[null, null, ORNAMENT_COUNT]}>
            <sphereGeometry args={[1, 32, 32]} />
            <meshStandardMaterial roughness={0.1} metalness={0.9} envMapIntensity={0.8} />
          </instancedMesh>
        );
      };

      const GiftBoxes = () => {
        const meshRef = useRef();
        const handState = useStore();
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const data = useMemo(() => new Array(BOX_COUNT).fill(0).map(() => {
          const y = (Math.random() - 0.5) * TREE_HEIGHT * 0.8;
          const hp = (y + TREE_HEIGHT/2) / TREE_HEIGHT;
          const r = TREE_RADIUS * (1.0 - hp) * (0.6 + Math.random() * 0.4); 
          const th = Math.random() * Math.PI * 2;
          return { tgt: new THREE.Vector3(r * Math.cos(th), y, r * Math.sin(th)), chs: randomSpherePoint(20), clr: LUXURY_PALETTE[Math.floor(Math.random() * LUXURY_PALETTE.length)], spd: Math.random() * 0.015 + 0.01, rs: (Math.random()-0.5)*0.02, scl: Math.random()*0.3+0.2 };
        }), []);
        useEffect(() => {
          if (meshRef.current) {
            data.forEach((d, i) => meshRef.current.setColorAt(i, d.clr));
            meshRef.current.instanceColor.needsUpdate = true;
          }
        }, []);
        useFrame(() => {
          if (!meshRef.current) return;
          const exp = handState.gesture === HandGesture.OPEN_PALM;
          data.forEach((d, i) => {
            meshRef.current.getMatrixAt(i, dummy.matrix);
            dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
            dummy.position.lerp(exp ? d.chs : d.tgt, exp ? 0.03 : d.spd);
            dummy.rotation.x += d.rs; dummy.rotation.z += d.rs;
            dummy.scale.setScalar(d.scl); dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          });
          meshRef.current.instanceMatrix.needsUpdate = true;
        });
        return (
          <instancedMesh ref={meshRef} args={[null, null, BOX_COUNT]}>
            <boxGeometry args={[1, 1, 1]} />
            <meshStandardMaterial roughness={0.2} metalness={0.8} />
          </instancedMesh>
        );
      };

      const GoldenDust = () => {
        const shaderRef = useRef();
        const { attr } = useMemo(() => {
          const pos = [], phs = [], spd = [];
          for (let i = 0; i < DUST_COUNT; i++) {
            const y = (Math.random() - 0.5) * TREE_HEIGHT;
            const r = Math.sqrt(Math.random()) * TREE_RADIUS * (1.0 - (y + TREE_HEIGHT/2) / TREE_HEIGHT);
            const th = Math.random() * Math.PI * 2;
            pos.push(r * Math.cos(th), y, r * Math.sin(th));
            phs.push(Math.random() * Math.PI * 2); spd.push(Math.random() * 0.5 + 0.2);
          }
          return { attr: { pos: new Float32Array(pos), phs: new Float32Array(phs), spd: new Float32Array(spd) } };
        }, []);
        useFrame(({ clock }) => { if (shaderRef.current) shaderRef.current.uniforms.uTime.value = clock.getElapsedTime(); });
        return (
          <points>
            <bufferGeometry>
              <bufferAttribute attach="attributes-position" count={DUST_COUNT} array={attr.pos} itemSize={3} />
              <bufferAttribute attach="attributes-aPhase" count={DUST_COUNT} array={attr.phs} itemSize={1} />
              <bufferAttribute attach="attributes-aSpeed" count={DUST_COUNT} array={attr.spd} itemSize={1} />
            </bufferGeometry>
            <shaderMaterial ref={shaderRef} vertexShader={dustVertexShader} fragmentShader={dustFragmentShader} transparent depthWrite={false} blending={THREE.AdditiveBlending} uniforms={{ uTime: { value: 0 } }} />
          </points>
        );
      };

      const SnowflakeTopper = () => {
        const groupRef = useRef();
        const glowRef = useRef();
        useFrame(({ clock }) => {
          const t = clock.getElapsedTime();
          if (groupRef.current) { groupRef.current.rotation.y = t * 0.5; groupRef.current.rotation.z = Math.sin(t * 0.2) * 0.1; }
          if (glowRef.current) glowRef.current.uniforms.uTime.value = t;
        });
        const material = useMemo(() => new THREE.MeshStandardMaterial({ color: '#FFF8E7', roughness: 0.1, metalness: 1.0 }), []);
        const armGeo = useMemo(() => new THREE.BoxGeometry(0.15, 3.5, 0.1), []);
        return (
          <group position={[0, TREE_HEIGHT / 2 + 1.5, 0]}>
            <group ref={groupRef} scale={[1.8, 1.8, 1.8]}>
              {[0, 60, 120].map((angle, i) => (
                <group key={i} rotation={[0, 0, THREE.MathUtils.degToRad(angle)]}><mesh geometry={armGeo} material={material} /></group>
              ))}
            </group>
            <pointLight color="#FFF8E7" intensity={150} distance={30} /> 
            <Billboard>
              <mesh>
                <planeGeometry args={[10, 10]} />
                <shaderMaterial ref={glowRef} vertexShader={starGlowVertexShader} fragmentShader={starGlowFragmentShader} transparent depthWrite={false} blending={THREE.AdditiveBlending} uniforms={{ uTime: { value: 0 } }} />
              </mesh>
            </Billboard>
          </group>
        );
      };

      const Scene = () => {
        const { x, y, z, isPresent, gesture, pointer } = useStore();
        const lightRef = useRef();
        useFrame(({ camera }) => {
          if (isPresent) {
            const rad = 25 - (z * 0.1), az = x * 1.5, pol = Math.PI / 2 - (y * 0.5);
            camera.position.lerp(new THREE.Vector3(rad * Math.sin(pol) * Math.sin(az), rad * Math.cos(pol), rad * Math.sin(pol) * Math.cos(az)), 0.05);
            camera.lookAt(0, 0, 0);
          }
          if (lightRef.current && pointer) {
            lightRef.current.position.lerp(new THREE.Vector3(pointer.x, pointer.y, pointer.z), 0.2);
            lightRef.current.intensity = THREE.MathUtils.lerp(lightRef.current.intensity, gesture === HandGesture.POINTING ? 300 : 0, 0.1);
          }
        });
        return (
          <>
            <PerspectiveCamera makeDefault position={[0, 0, 25]} fov={50} />
            <Environment preset="city" />
            <ambientLight intensity={0.4} color={COLOR_RICH_GOLD} />
            <pointLight position={[15, 15, 15]} intensity={100} color={COLOR_GOLD} />
            <TreeBase /><Foliage /><Ornaments /><GiftBoxes /><ParticleRibbon /><GoldenDust /><Snowflakes /><SnowflakeTopper />
            <pointLight ref={lightRef} color={COLOR_GOLD} distance={15} />
            <EffectComposer>
              <Vignette eskil={false} offset={0.1} darkness={1.0} />
              <Bloom luminanceThreshold={0.8} intensity={1.2} />
            </EffectComposer>
            <OrbitControls enableZoom={true} enablePan={false} />
          </>
        );
      };

      const App = () => (
        <div className="w-full h-screen bg-black overflow-hidden relative">
          <HandTracker />
          <Canvas><Scene /></Canvas>
          <div className="absolute bottom-6 right-6 z-40 text-right pointer-events-none">
            <h1 className="text-4xl md:text-6xl font-serif text-[#FFD700] tracking-widest uppercase" style={{textShadow: "0 0 20px #FFD700"}}>Merry<br/>Christmas</h1>
            <div className="w-full h-1 bg-gradient-to-r from-transparent via-[#FFD700] to-transparent my-2"></div>
            <p className="text-[#DAA520] font-serif tracking-[0.3em] text-sm uppercase">Golden Holidays</p>
          </div>
        </div>
      );

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>